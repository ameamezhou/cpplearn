C++ 的编译器如何工作

思考
	C++ 编译器的思路是什么？
	C++ 编译器实际上负责做的事是什么？
	我们写的C++ 代码都是文本文件，我们通过什么方法将文本转化为一个可以运行的应用程序？
	


从文本形式到可执行的二进制文件，我们基本上有两个主要的操作需要进行：
	其中一个叫做编译，另一个叫做链接

这次的笔记先讨论编译
=========================================================================
其实仅从编译这一点上来说，C++编译器做的工作无非就是将我们的文本文件转换它们变成一种成为目标文件的中间格式，obj文件，这些obj文件可以传递到链接，这个链接可以做他所有的要链接的事情，不管这里链接的逻辑如何，我们首先要讨论的就是编译

编译器在生成这些obj文件的时候实际上做了几件事情：
	1、 首先它需要预处理我们的代码，这意味着所有的预处理语句都会先处理；
	2、 当我们的代码经过了预处理，没接下来我们将或多或少地进行记号化和解析，基本上把这个英语的C++语言整理成编译器能够正在理解和运行的格式，这基本导致了所谓的抽象语法树被创建。它实际上是我们代码的一种表示，但是是抽象的语法树；
	3、 编译器每天的工作是转换我们所有的代码，转换成常量数据或指令。一旦编译器创建了这个抽象语法树，它就可以开始实际生成代码，这段代码就是实际的机器，也就是我们的CPU即将执行的代码。我们还得到了其他各种数据，比如一个存储所有常量变量的地方，这基本上就是编译器所做的一切。

===========================================================================================
这里提到了抽象语法树的概念  我们就来简单讲一下：
抽象语法树（abstract syntax code，AST）是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，这所以说是抽象的，是因为抽象语法树并不会表示出真实语法出现的每一个细节，比如说，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现。抽象语法树并不依赖于源语言的语法，也就是说语法分析阶段所采用的上下文无文文法，因为在写文法时，经常会对文法进行等价的转换（消除左递归，回溯，二义性等），这样会给文法分析引入一些多余的成分，对后续阶段造成不利影响，甚至会使合个阶段变得混乱。因些，很多编译器经常要独立地构造语法分析树，为前端，后端建立一个清晰的接口。

抽象语法树在很多领域有广泛的应用，比如浏览器，智能编辑器，编译器。

举一些很简单的例子

四则运算表达式：
	4 + 3*(8-6) + 7 抽象语法树为：
			add(+)
		   /      \
		add(+)     2
	   /      \
	   1     mul(*)
	   		/      \
	   	   3       sub(-)
	   	   		  /      \
	   	   		 4        1

xml：
<letter>
  <address>
    <city>ShiChuang</city>
  </address>
  <people>
    <id>12478</id>
    <name>Nosic</name>
  </people>
</letter>
		
			 		letter
			 	   /       \
			   address    people
			  / 		 /      \
			city        id       name
		txt=ShiChuan txt=12478  txt=Nosic
		
程序1：
while b != 0
{
    if a > b
        a = a-b
    else
        b = b-a
}
return a

http://blog.chinaunix.net/attachment/201203/19/26750235_1332133743gQH0.png

程序2：
sum=0
for i in range(0,100)
    sum=sum+i
end

http://blog.chinaunix.net/attachment/201203/19/26750235_1332133574qqK6.png

==========================================================================================

首先讲一下预处理语句
我们最常用的预处理语句就是 #include
这个语句的作用就是浏览我们所有的文件  找到需要引入的文件内容，并将所有的东西写入到文件中

这里我们直接举个最简单的例子

math.cpp
```C++
int Multiply(int a, int b)
{
	return a * b;

```
ok 这就是这个cpp文件的全部内容，我们当然知道这里少了一个}是不能被编译的

endBrace.cpp
```C++
}
```
ok 这就是这个文件的全部内容
然后改写下math.cpp
```C++
int Multiply(int a, int b)
{
	return a * b;
#include "endBrace.cpp"
```
就可以编译通过了
