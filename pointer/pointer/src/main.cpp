#include <iostream>
#include "log.h"


#define LOG(x) std::cout << x << std::endl

int main() 
{
	// pointers  指针是c++中最重要的一环
	// 先学习原始指针，现在c++ 分为原始指针和智能指针
	// 我们写程序其实就是利用内存，对于计算机来说，内存就是它的一切
	// 因为我们所有的程序都是在内存里运行的
	// 所以 在我们以后学习编程或者说编程过程中  最重要的一件事情 就是内存
	// 当你编写一个程序并启动它时 程序的所有东西都会被加载进内存里 你要做的事情，你对计算机的指令其实都是在内存中的
	// cpu就是这样去访问我们给出的指令并做出相应的计算的
	// 
	// 最最最重要的概念  指针其实就是一种存储内存地址的数字！
	// 
	// 指针其实就是一种存储内存地址的数字！
	// 
	// 指针其实就是一种存储内存地址的数字！
	// 重要的事情说三遍
	//
	
	// 创建一个最纯粹的指针， 空指针 void 的意思就是没有类型  no type
	// 这个意思就是 我们不在乎这个指针指向的数据是什么类型，我们只需要要给存储内存地址的一串数字罢了
	 void* ptr1 = 0; // 我们给这个指针的内存地址是0 这是什么意思？ 0肯定不是一个有效的内存地址，因为内存地址不会一直到0
	// 这里给到的0指针的意思就是它是一个完全无效的指针，无效指针完全可以接受的状态
	// 我们不能直接在0指针这里进行读取和写入 这样做的话程序会崩溃  所以我们有一种更优雅的写法
	void* ptr2 = NULL; // 这实际上是一个#define  我们鼠标放上去看会看到  #define NULL 0 的字样
	// 亦或者说我们可以用 c++上的另一个关键字
	void* ptr3 = nullptr;
	// 这就是我们能够实现的最简单的指针

	int var = 8; // 我们创建的每个变量都有一个内存地址，因为我们需要要给地方来存储这个变量
	// 如果我们想知道这个变量的内存地址 在内存的哪个地方  我们可以用 &运算符 来做到
	void* ptr4 = &var; // 000000EBBE2FFC64 每次的结果不一样  这里只是一次展示 这里我们可以看到  这个结果实际上还是一个数字
	int* ptr5 = &var; // 这两个并没有任何区别  更换成任何类型的指针它都不会有任何区别
	//LOG(ptr4);
	// 指针并不是保存变量a这样值的本身  保存的十个内存地址  内存地址也是一个值  也是一个整数
	// 这个整数多大，这个指针多大，取决于很多东西，可能是32位的整数，也可能是64位的整数 这不重要 只需要知道它是一个整数
	// 
	double* ptr6 = (double*)&var;
	// 对于指针来说 类型其实不重要，不管是什么类型 只要是指针它就是一个整数，但是为什么我们又要给它设定是某个类型的指针呢？
	// 因为类型对该内存的操作很有用  如果我想对这个内存地址的内容进行读写，类型可以帮助我让编译器知道我要写的是什么东西
	// 比如一个整数应该是4个字节 所以我要设置一个整数，它就会设置四个字节的内存  总的来说  对于类型并没有什么意义，因为指针就是个整数
	//
	void* ptr7 = &var;
	// 逆向引用指针 就可以进行指针对应数据的读写和修改
	// *ptr7 = 10; 这里会报错，这也是为什么空指针也是指针但是用的很少的原因
	// 因为计算机不知道怎么将值写入一个空指针 因为计算机没办法判断这个数据类型 10到底是short？还是int？还是longlong？
	// 因为计算机是很笨的  你不告诉他  它就不知道该怎么写入 
	*ptr5 = 10;
	// 这里再去查内存就会发现值为0a了
	// 指针是一个整数，也是需要被存储的，他们都会存在堆栈中，但是如果我们想申请一块有一定尺寸的内存
	// 我们可以
	char* buffer = new char[8];
	// char是一个字节 char指针就是指向一块地址，类型是char类型  我们来申请一块size为8字节的内存 
	// 这里我们真正创建的是一个八个字节的内存 并且此时返回了一个指向那块内存开始的指针
	// 然后我们可以使用一个叫memset的函数 它用我们指定的数据填充一个内存块 
	// 它接收的参数为：
	//	一个指针，这个指针将会是内存块开始的指针
	//	需要取的值, 比如0
	//	然后再是这块内存块的大小  应该填入多少字节  
	// 运行看下效果
	//
	memset(buffer, 0, 8);
	// 当我们完成它后也应该删除数据
	// 可以通过delete  我们知道我们是通过数组来分配堆内存  所以用delete也要用数组符号来删除buffer
	// 
	char** ptr9 = &buffer;
	// 0x000000dd760ff698  每次运行的结果不一样  所以不要复现 只是举个例子
	// 0x000000DD760FF698  00 19 51 8b b9 02 00 00 访问到的结果是这样的， 因为这里的内存展示是反向的  所以我们要重新排列得到
	// 000002b98b511900  --> 访问后得到 0x000002B98B511900  00 00 00 00 00 00 00 00  buffer指针指向的值  这里000002b98b511900 就是buffer的值

	delete[] buffer;
	// 最重要的是  指针也是变量  变量也需要存储在内存中， 所以我们完全可以有一个pointer 指向一个pointer
	// 甚至可以多个指针互相指向
	//
	std::cin.get();

}