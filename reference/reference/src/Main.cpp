// 引用是指针的扩展
// 从根本上来说  引用只是指针的伪装 它们只是指针上的语法糖  让它更容易阅读 更容易理解
// 不像指针  你可以创建一个新的指针变量，然后设置它等于空指针或者类似的东西
// 引用不行，因为引用必须“引用”已经存在的变量，引用本身不是一个新的变量，它并不占用内存  它们没有真正的存储空间
// 它们不像典型的变量，因为它们是作为一个变量的引用
// reference must quote
//

#include <iostream>

#define LOG(x) std::cout << x << std::endl

void Increment(int value)
{
	value++;
}

void Increment1(int* value)
{
	(*value)++;
	// 这里 *value 不加 * 的话就是一个内存地址  只是在操作内存地址的整数值  并没有达到修改我们目标值的目的
	//  然后这里要考虑到运算的先后顺序  *value++ 它会先++ 再进行逆向引用，所以这里给它加个括号
	//
}

void Increment2(int& value)
{
	value++;
}

int main() 
{
	int a = 5;
	int* b = &a;
	// 这里和指针指向 &a(a的内存地址)的使用不同  因为&符号实际上是类型的一部分
	// 这里要注意区别  直接等于一个现有变量就行了
	// 这就是一个引用，这里ref实际上这个变量并不会在运行的时候存在  只会存在于我们的源代码中
	// 就算现在编译  你野不回得到两个变量 a 和 ref  你只会得到a
	int& ref = a;
	// 现在我们做的就是  我们使用 ref 就像使用a 一样，如果我们现在让 ref = 2 然后打印 a 会发现我们更改的其实就是 a 的值
	ref = 2;
	LOG(a);
	// 这种情况我们的引用就不是一个类似于指针的东西  编译器并不需要实际创建一个新的变量  这里相当于给a起了个别名 ref
	// 这里编译的代码就相当于你设置了 a = 2
	// 这里在工作中的应用就是方便我们的工作（虽然说我也不知道用在什么场景）

	// 来  这里我给你举例个场景：
	// 假设我们想写一个函数 void Increment 整型变量递增  如果我们这样写个函数
	// 可以看到我们并没有把他作为一个指针或者引用或者类似的东西传递，它会copy一个值为5的变量到value中，复制会创建一个全新的变量value
	// 就像
	// void Increment(int value)
	// {
	//    int value = 5;
	// 	  value++;
	// }
	//
	Increment(a);
	LOG(a);

	// 所以这里我们需要做的就是通过引用来传递变量 这样它才会递增  因为我真正像影响的变量是a
	// 我们有说过指针  指针指的就是我们的内存地址，  当然可以通过指针来解决
	// 因为上面说到我们只是拷贝了5这个值过去，而不是直接操作的a变量，所以我们可以直接把a变量的内存地址传过去
	// 我们就可以通过找到内存地址来修改对应的值达到目的
	// 
	//
	Increment1(&a);
	LOG(a);

	// 这里就是引用的用法  这里在编译的时候就不是拷贝值了 而是直接引用了 a 参数进行运算 所以可以成功修改a的值
	// 相较于指针来说  引用会让你的代码更简洁  而不是像指针 操作比较多
	Increment2(ref);
	LOG(a);

	// 引用还有重要的一点  一旦你声明了一个引用   你不能改变它引用的东西
	// 假设我有两个整数  c 和 d
	int c = 8;
	int d = 5;

	int& ref1 = c;
	ref1 = d;  // 是不能这样做的  因为这里你相当于不是修改引用对象  而是将 c的值改为d的值  就是 c = 5 d = 5
	// = 是赋值的符号
	// 当你声明一个引用的时候你必须马上给它赋值，因为它必须引用一些东西  因为它不是一个真正的变量

	std::cin.get();
}